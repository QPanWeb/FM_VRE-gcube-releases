package gr.cite.geoanalytics.client;

import java.io.IOException;
import java.io.Serializable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.broadcast.Broadcast;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import gr.cite.clustermanager.actuators.functions.ExecutionMonitor;
import gr.cite.clustermanager.actuators.functions.ExecutionNotifier;
import gr.cite.clustermanager.actuators.layers.DataCreatorGeoanalytics;
import gr.cite.clustermanager.model.functions.ExecutionDetails;
import gr.cite.clustermanager.model.functions.ExecutionStatus;
import gr.cite.clustermanager.model.layers.GosDefinition;
import gr.cite.clustermanager.model.layers.ZNodeData.ZNodeStatus;
import gr.cite.clustermanager.trafficshaping.TrafficShaper;
import gr.cite.gaap.datatransferobjects.ShapeMessenger;
import gr.cite.geoanalytics.dataaccess.entities.layer.DataSource;
import gr.cite.geoanalytics.dataaccess.entities.layer.Layer;
import gr.cite.geoanalytics.dataaccess.entities.layer.LayerTenant;
import gr.cite.geoanalytics.dataaccess.entities.principal.Principal;
import gr.cite.geoanalytics.dataaccess.entities.project.Project;
import gr.cite.geoanalytics.dataaccess.entities.project.ProjectLayer;
import gr.cite.geoanalytics.dataaccess.entities.tenant.Tenant;
import gr.cite.geoanalytics.dataaccess.geoserverbridge.elements.Bounds;
import gr.cite.geoanalytics.dataaccess.geoserverbridge.elements.FeatureType;
import gr.cite.geoanalytics.dataaccess.geoserverbridge.elements.GeoserverLayer;
import gr.cite.gos.client.GeoserverManagement;
import gr.cite.gos.client.ShapeManagement;

@Component
public class GeoanalyticsImportManagement extends GeoanalyticsManagement implements Serializable{

	private static final long serialVersionUID = -217872471686069616L;
	
	private static final Logger logger = LoggerFactory.getLogger(GeoanalyticsImportManagement.class);

	@Autowired private DataCreatorGeoanalytics dataCreatorGeoanalytics;
	@Autowired private ExecutionNotifier executionNotifier;
	@Autowired private ExecutionMonitor executionMonitor;
	
	private GeoanalyticsImportManagement(){}
	
	public GeoanalyticsImportManagement(String authenticationStr){
		super(authenticationStr);
	}
	
	public void importLayerLocal(String geoanalyticsEndpoint, GosDefinition gosDefinition, String layerName, String styleName, String tenantID, String creatorID, String projectID, TrafficShaper trafficShaper, List<Map.Entry<String, Class>> functionResultsSchema ) throws Exception {
		//create Layer on geoanalytics
		Layer layer = new Layer();
		layer.setIsTemplate((short)0);
		layer.setName(layerName);
		layer.setDataSource(DataSource.PostGIS);
		layer.setDescription("This layer is generated by geoanalytics functions");
		layer.setReplicationFactor(1);
		layer.setStyle(styleName);
		layer.setWorkspace(gosDefinition.getGeoserverWorkspace());
		
		Principal principal = new Principal();
		principal.setId(UUID.fromString(creatorID));
		layer.setCreator(principal);
		
		Set<LayerTenant> layerTenants = new HashSet<LayerTenant>();
		LayerTenant lt = new LayerTenant();
		Tenant t = new Tenant();
		t.setId(UUID.fromString(tenantID));
		lt.setTenant(t);
		layerTenants.add(lt);
		layer.setLayerTenants(layerTenants);
		
		Project project = new Project();
		project.setId(UUID.fromString(projectID));
		project.setIsTemplate(false);
		Set<ProjectLayer> projectLayers = new HashSet<ProjectLayer>();
		ProjectLayer pl = new ProjectLayer();
		pl.setProject(project);
		projectLayers.add(pl);
		layer.setProjectLayers(projectLayers);
		
		String layerID = createLayer(geoanalyticsEndpoint, layer);
		
		if(layerID==null || layerID.isEmpty()) //no layer was created, so it can't proceed.
			throw new Exception("Error while creating the layer on Geoanalytics to host the results of the analytics function... Will not proceed with function execution!");
		
		layer.setId(UUID.fromString(layerID));
		
		logger.debug("Function on all executors has completed successfully. Adding layer on geoanalytics, geoserver and notifying cluster");
		//means that all were successful, so go on with the remaining layer creation (create views, create geoserver entries, etc)
		//1. create layer view (optional)
		ShapeManagement sm = new ShapeManagement(authenticationStr);
		GosDefinition gosDefinition2 = trafficShaper.getGosForNewLayer();
		sm.applyOnView(gosDefinition2.getGosEndpoint(), viewCreation(layerID, functionResultsSchema));
		//2. create geoserver layer mapping (optional)
		addGeoserverLayer(gosDefinition2, layerID, "point");
		//3. Notify zookeeper about the new layer
		dataCreatorGeoanalytics.addLayer(layerID, ZNodeStatus.ACTIVE, gosDefinition2.getGosIdentifier());
		//4. notify the zookeeper about the status of the execution
	}
	
	
	
	
	
	public void importLayerFromRDD(String executionID, String geoanalyticsEndpoint, GosDefinition gosDefinition, String layerName, String styleName, String tenantID, String creatorID, String projectID, JavaRDD<List<ShapeMessenger>> featuresRDD, String srid, List<Map.Entry<String, Class>> functionResultsSchema) throws Exception{
		
		ExecutionDetails currentExecution = executionMonitor.getLatestExecutionDetailsOf(executionID);

		JavaSparkContext jsc = new JavaSparkContext(featuresRDD.context());
		
		if(geoanalyticsEndpoint==null || geoanalyticsEndpoint.isEmpty() || gosDefinition==null || gosDefinition.getGosEndpoint()==null || gosDefinition.getGosEndpoint().isEmpty())
			throw new Exception("No gos or geoanalytics endpoint were correct: geoanalyticsEP="+geoanalyticsEndpoint+" gosEP="+gosDefinition.getGosEndpoint());
		
		//create Layer on geoanalytics
		Layer layer = new Layer();
		layer.setIsTemplate((short)0);
		layer.setName(layerName);
		layer.setDataSource(DataSource.PostGIS);
		layer.setDescription("This layer is generated by geoanalytics functions");
		layer.setReplicationFactor(1);
		layer.setStyle(styleName);
		layer.setWorkspace(gosDefinition.getGeoserverWorkspace());

		Principal principal = new Principal();
		principal.setId(UUID.fromString(creatorID));
		layer.setCreator(principal);
		
		Set<LayerTenant> layerTenants = new HashSet<LayerTenant>();
		LayerTenant lt = new LayerTenant();
		Tenant t = new Tenant();
		t.setId(UUID.fromString(tenantID));
		lt.setTenant(t);
		layerTenants.add(lt);
		layer.setLayerTenants(layerTenants);
		
		Project project = new Project();
		project.setId(UUID.fromString(projectID));
		project.setIsTemplate(false);
		Set<ProjectLayer> projectLayers = new HashSet<ProjectLayer>();
		ProjectLayer pl = new ProjectLayer();
		pl.setProject(project);
		projectLayers.add(pl);
		layer.setProjectLayers(projectLayers);
		
		
		String layerID = createLayer(geoanalyticsEndpoint, layer);
		
		if(layerID==null || layerID.isEmpty()) //no layer was created, so it can't proceed.
			throw new Exception("Error while creating the layer on Geoanalytics to host the results of the analytics function... Will not proceed with function execution!");
		
		layer.setId(UUID.fromString(layerID));
		
		
		Broadcast<String> sridBC = jsc.broadcast(srid);
		Broadcast<String> layerIdBC = jsc.broadcast(layerID);
		Broadcast<String> creatorIdBC = jsc.broadcast(creatorID);
		Broadcast<String> authStrBC = jsc.broadcast(authenticationStr);
//		Broadcast<String> geoanalyticsEndpointBC = jsc.broadcast(geoanalyticsEndpoint);
		Broadcast<GosDefinition> gosDefinitionBC = jsc.broadcast(gosDefinition);
		
		
		Set<Boolean> results = featuresRDD
				.map(new Mapper(layerIdBC.getValue(), creatorIdBC.getValue(), authStrBC.getValue(), gosDefinitionBC.getValue().getGosEndpoint()))
				.reduce(new Reducer());
		
		
		//if successful, create also the Layer on geoanalytics db, else rollback the shapes on GOS
		if(results.contains(new Boolean(false))){ 
			logger.debug("Error while doing the computations for the analytics... one or more tasks reported fail status to driver... performing rollback!");
			//means that there was at least one failed on executors, so rollback
			ShapeManagement sm = new ShapeManagement(authenticationStr);
			//1. delete from geoserver layer mappings (optional)
			GeoserverManagement gm = new GeoserverManagement(authenticationStr);
			gm.deleteGeoserverLayer(gosDefinition.getGosEndpoint(), layerID, layer.getDataSource());
			//2. delete layer view (optional)
			sm.applyOnView(gosDefinition.getGosEndpoint(), viewDeletion(layerID));
			//3. delete shapes
			sm.deleteShapesOfLayer(gosDefinition.getGosEndpoint(), layerID);
			//4. delete layer
			deleteLayer(geoanalyticsEndpoint, layer);
			//5. update state on zookeeper
			currentExecution.setProgress(100);
			currentExecution.setStopTimestamp(System.currentTimeMillis());
			currentExecution.setStatus(ExecutionStatus.FAILED);
			executionNotifier.notifyAbout(currentExecution);
			// finally throw an exception notifying about the rollback
			throw new Exception("Error while doing the computations for the analytics... Performed a rollback!");
		}
		else {
			logger.debug("Function on all executors has completed successfully. Adding layer on geoanalytics, geoserver and notifying cluster");
			//means that all were successful, so go on with the remaining layer creation (create views, create geoserver entries, etc)
			//1. create layer view
			ShapeManagement sm = new ShapeManagement(authenticationStr);
			sm.applyOnView(gosDefinition.getGosEndpoint(), viewCreation(layerID, functionResultsSchema));
			//2. create geoserver layer mapping (optional)
			addGeoserverLayer(gosDefinition, layerID, layer.getStyle());
			//3. Notify zookeeper about the new layer
			dataCreatorGeoanalytics.addLayer(layerID, ZNodeStatus.ACTIVE, gosDefinition.getGosIdentifier());
			//4. notify the zookeeper about the status of the execution
			currentExecution.setProgress(100);
			currentExecution.setStopTimestamp(System.currentTimeMillis());
			currentExecution.setStatus(ExecutionStatus.SUCCEEDED);
			currentExecution.setLayerID(layerID);
			executionNotifier.notifyAbout(currentExecution);
		}
		
	}
	
	
	public String createLayer(String geoanalyticsEndpoint, Layer layer){
		
		MultiValueMap<String, String> headers = new LinkedMultiValueMap<String, String>();
		headers.add(super.HEADER_AUTHENTICATION_PARAM_NAME, authenticationStr);
		headers.add("Content-Type", "application/json");

		RestTemplate restTemplate = new RestTemplate();
		restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());
		HttpEntity<Layer> request = new HttpEntity<Layer>( layer, headers);
		return restTemplate.postForObject(geoanalyticsEndpoint+"/createLayerSpark", request, String.class);
		
	}
	
	public String deleteLayer(String geoanalyticsEndpoint, Layer layer) {
		
		MultiValueMap<String, String> headers = new LinkedMultiValueMap<String, String>();
		headers.add(super.HEADER_AUTHENTICATION_PARAM_NAME, authenticationStr);
		headers.add("Content-Type", "application/json");

		RestTemplate restTemplate = new RestTemplate();
		restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());
		HttpEntity<Layer> request = new HttpEntity<Layer>( layer, headers);
		return restTemplate.postForObject(geoanalyticsEndpoint+"/deleteLayerSpark", request, String.class);
	}
	
	
	public String viewCreation(String layerID, List<Map.Entry<String, Class>> fieldName_Datatype_Pairs){
		StringBuilder view = new StringBuilder();
		view.append("CREATE MATERIALIZED VIEW \""+layerID+"\" AS SELECT s.\"SHP_Geography\"::geometry AS \"SHP_Geography\", s.\"SHP_ID\"");
		for(Map.Entry<String, Class> name_DataType : fieldName_Datatype_Pairs)
			view.append(",(xpath('//extraData/"+name_DataType.getKey()+"/text()'::text, s.\"SHP_ExtraData\"))[1]::text::"+toPGSqlDataType(name_DataType.getValue())+" AS "+name_DataType.getKey());
		view.append(" FROM \"Shape\" s  WHERE s.\"SHP_LayerID\" = '"+layerID+"'::uuid WITH DATA");
		return view.toString();
	}
	
	public String viewDeletion(String layerID){
		return "DROP MATERIALIZED VIEW IF EXISTS \""+layerID+"\"";
	}
	

	private String toPGSqlDataType(Class javaDataClass){
		if(javaDataClass == Float.class)
			return "decimal";
		if(javaDataClass == Double.class)
			return "numeric";
		if(javaDataClass == Integer.class)
			return "integer";
		if(javaDataClass == Long.class)
			return "bigint";
		if(javaDataClass == String.class)
			return "text";
		return "text";
	}
	
	
	
	private void addGeoserverLayer(GosDefinition gosDefinition, String layerID, String style) throws IOException{
		
		Bounds boundingBox = new Bounds();
		boundingBox.setMinx(0);
		boundingBox.setMiny(0);
		boundingBox.setMaxx(180);
		boundingBox.setMaxy(90);
		boundingBox.setCrs("EPSG:4326");

		FeatureType featureType = new FeatureType();
		featureType.setDatastore(gosDefinition.getDatastoreName());
		featureType.setWorkspace(gosDefinition.getGeoserverWorkspace());
		featureType.setEnabled(true);
		featureType.setName(layerID);
		featureType.setTitle(layerID);
		featureType.setSrs("EPSG:4326");
		featureType.setNativeCRS("EPSG:4326");
		featureType.setNativeBoundingBox(boundingBox);
		featureType.setLatLonBoundingBox(boundingBox);

		GeoserverLayer geoserverLayer = new GeoserverLayer();
		geoserverLayer.setDatastore(gosDefinition.getDatastoreName());
		geoserverLayer.setWorkspace(gosDefinition.getGeoserverWorkspace());
		geoserverLayer.setEnabled(true);
		geoserverLayer.setDefaultStyle(style);
		geoserverLayer.setId(layerID);
		geoserverLayer.setTitle(layerID);
		geoserverLayer.setType("VECTOR");
		
		Integer minScale = null;//layerConfig.getMinScale();
		Integer maxScale = null;//layerConfig.getMaxScale();
		
		Map<String, String> layerStyles = new HashMap<String, String>();//configurationManager.getLayerStyles();
		layerStyles.put("point", style);
		
		GeoserverManagement gm = new GeoserverManagement(authenticationStr);
		gm.addGeoserverLayer(gosDefinition.getGosEndpoint(), geoserverLayer, featureType, layerStyles, minScale, maxScale);
	}
	
	
}
