/*
 * 
 * Copyright 2012 FORTH-ICS-ISL (http://www.ics.forth.gr/isl/) 
 * Foundation for Research and Technology - Hellas (FORTH)
 * Institute of Computer Science (ICS) 
 * Information Systems Laboratory (ISL)
 * 
 * Licensed under the EUPL, Version 1.1 or â€“ as soon they
 * will be approved by the European Commission - subsequent 
 * versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the
 * Licence.
 * You may obtain a copy of the Licence at:
 * 
 * http://joinup.ec.europa.eu/software/page/eupl/licence-eupl
 * 
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the Licence is
 * distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the Licence for the specific language governing
 * permissions and limitations under the Licence.
 * 
 */
package gr.forth.ics.isl.gwt.xsearch.server;

import gr.forth.ics.isl.xsearch.configuration.Conf;
import gr.forth.ics.isl.xsearch.configuration.Resources;
import java.io.*;
import java.nio.channels.FileLock;
import java.util.*;
import org.apache.log4j.Appender;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Layout;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.gcube.application.framework.core.session.ASLSession;
import org.gcube.common.resources.gcore.GCoreEndpoint;
import org.gcube.common.scope.api.ScopeProvider;
import org.gcube.resources.discovery.client.api.DiscoveryClient;
import org.gcube.resources.discovery.client.api.DiscoveryException;
import org.gcube.resources.discovery.client.api.InvalidResultException;
import org.gcube.resources.discovery.client.queries.api.SimpleQuery;
import static org.gcube.resources.discovery.icclient.ICFactory.client;
import static org.gcube.resources.discovery.icclient.ICFactory.queryFor;

/**
 * A class that implements a functionality which caches to a file the 
 * XSearch services that are available per gcube scope.
 * @author kitsos Ioannis (kitsos@ics.forth.gr)
 */
public class ExploitationOfIS implements Serializable  {
	
	
	private final String XSEARCH_SERVICENAME = "XSearchService"; 
	private String diskLocation = System.getProperty("catalina.home") + "/webapps/" 
			  					+ XSearchServiceImpl.class.getProtectionDomain().getCodeSource().getLocation().getPath().toString().split("webapps/")[1].split("/")[0] 
			  					+ "/cache";
	
	private ASLSession aslSession;
	private String gCubeScope;
	private boolean firstTimeCacheCreation = false;
	public boolean updateCache = false;	
	long oldCreationTime = 0;
        private final Logger logger=Resources.initializeLogger(this.getClass().getName());
	

        /*
         * Initializes the needed values and checks if the cache file 
         * exists otherwise it creates it.
         */
	public ExploitationOfIS(ASLSession aslSession){
            this.gCubeScope =  aslSession.getScope();
            this.aslSession = aslSession;

            File f = new File(diskLocation);
            if(!f.exists()){
            // If the file does not exist, then create it and add the info about the Xsearch endpoints
                    retrieveXSearchServiceEndpointsThroughIS();
            } 
	}
	
	/**
	 * Sets the XSearchService IP by asking IS for the services with name "XSearchService" that
	 * are hosted to the current scope. */
	public void retrieveXSearchServiceEndpointsThroughIS(){
		
		firstTimeCacheCreation = true;
                this.logger.debug("The current scope that as returned from ASL is: "+ gCubeScope);
				
//		ISClient client;
		Queue<String> xsearchEndpointsStack = new LinkedList<>();
		Map<String, Queue<String>> map = new HashMap<>();
		try {
                    ScopeProvider.instance.set(this.gCubeScope);
                    SimpleQuery query=queryFor(GCoreEndpoint.class).addCondition("$resource/Profile/ServiceName/text() eq '"+this.XSEARCH_SERVICENAME+"'")
                        .setResult("$resource/Profile/AccessPoint/RunningInstanceInterfaces/Endpoint/text()");
                
                    DiscoveryClient<String> client=client();
                
                    List<String> results=client.submit(query);
                    for(String res : results){
                        if(!res.endsWith("/"))
                            res+="/";
                        this.logger.debug("Found xsearch-service instance: "+res);
                        xsearchEndpointsStack.add(res);
                    }
                }catch(DiscoveryException | IllegalStateException | InvalidResultException ex){
                    this.logger.error("ERROR: occured while retrieving xsearch-service instances\n"+ex.toString());
                    ex.printStackTrace();
                }
                
//		 if (updateCache){
//			System.out.println("egine update");
//			xsearchEndpointsStack.add("EGINE UPDATE");
//		}*/
		
		map.put(this.gCubeScope, xsearchEndpointsStack);		
		serialize(map);		
	}
	
	/**
	 * Updates the URL's of the XSearch Services that are available.
	 */
	public void updateXSearchServiceURL(){
		
		
		// Read the stack with the services from local file
		Map<String, Queue<String>> map = deserialize();		
		Queue<String> xsearchEndpointsQueue = map.get(this.gCubeScope); 
		
		// If the queue of the current scope is null
		// means that is the first time that the portlet added in this scope
		// so it is nessecary to query the IS
		if(xsearchEndpointsQueue==null){
			retrieveXSearchServiceEndpointsThroughIS();
			
			// Deserialize and read the results of the IS query
			map = deserialize();
			xsearchEndpointsQueue = map.get(this.gCubeScope); 
		}
		
		if (xsearchEndpointsQueue.isEmpty()){
			Conf.XSearchServiceURL = null;
			
			// If no services available at current scope throw an exception
			try {
                            throw new IllegalArgumentException("No available service for the scope " + this.gCubeScope);
			} catch (IllegalArgumentException e) {
                            e.printStackTrace();
			}
			return;
		}else{
			Conf.XSearchServiceURL = xsearchEndpointsQueue.peek();
		}
		
		// Set the xsearch service url/endpoint
		if(Conf.XSearchServiceURL == null)
                    this.logger.error("There is no avaialble XSearchService for scope: "+this.gCubeScope);
		else
                    this.logger.debug("The XSearchService endpoint (found through ic-client) is "+Conf.XSearchServiceURL);
		
		// Remove the first element and put it at the end
		xsearchEndpointsQueue.add(xsearchEndpointsQueue.remove());	
		
		// Update maps queue
		map.remove(this.gCubeScope);
		map.put(this.gCubeScope, xsearchEndpointsQueue);
		
		// Store again the new stack
		if(!updateCache)// Only if the process is not followed by an update
			serialize(map);
	}
	
	/**
	 * Serializes a queue with the xsearch available endpoints
	 * @param map a map that for each gCube scope (key) has a Queue (value)
         * with the XSearch Service endpoints.
	 */
	public void serialize(Map<String, Queue<String>> map) {
		
		try{
			FileOutputStream fileOut = new FileOutputStream(diskLocation);
			FileLock lock = fileOut.getChannel().lock();
			ObjectOutputStream out = new ObjectOutputStream(fileOut);
					
			// Update creation time only if the cache was updated
			if(updateCache || firstTimeCacheCreation){
				out.writeLong(System.currentTimeMillis());
				firstTimeCacheCreation = false;
			}else{
				out.writeLong(oldCreationTime);
			}
			out.writeObject(map);
			
			lock.release();	
			out.close();
			fileOut.close();		
				
		} catch (IOException i) {
			i.printStackTrace();
		}
	}
	
	/**
	 * Deserializes the queue with the xsearch endpoints.
	 * @return a map that for each gCube scope (key) has a Queue (value)
         * with the XSearch Service endpoints.
	 */
	public Map<String, Queue<String>> deserialize() {
		Map<String, Queue<String>> xsearchInstancesMap = new HashMap<>();
		try {
			FileInputStream fileIn = new FileInputStream(diskLocation);
			ObjectInputStream in = new ObjectInputStream(fileIn);
			
			oldCreationTime = (long) in.readLong();
			updateCache = isTimeToUpdateCache(oldCreationTime);
			xsearchInstancesMap = ((Map<String, Queue<String>>) in.readObject());
			in.close();
			fileIn.close();
		} catch (IOException  | ClassNotFoundException ex) {
			ex.printStackTrace();
		}
                this.logger.debug("Deserializing XSearchService instances "+xsearchInstancesMap.keySet());
		
		return xsearchInstancesMap;
	}
	
	/** 
         *  Checks if is needed a cache update.
	 *  @param creationTimeInMillisecs  cache update interval 
         *  @return true if is needed to update the cache otherwise false
	 * */
	public boolean isTimeToUpdateCache(long creationTimeInMillisecs){
		
		long dif = (System.currentTimeMillis() - creationTimeInMillisecs);
                this.logger.debug("The XSearchService instances cache was created "+dif+" ms before");
	
		if (dif > convertMinutesToMilliseconds(Conf.cacheUpdateTimeInterval)){
                    this.logger.debug("More than "+Conf.cacheUpdateTimeInterval +" minutes have passed, so start updating the XSearchService instances cache");
                    return true;
		}else{
                    this.logger.debug("XSearchService instances cache is up-to-date");
                    return false;
		}
	}
	
	/**Convert minutes to milliseconds
	 * @param min minutes
         * @return the minutes in milliseconds
	 * */
	public long convertMinutesToMilliseconds(int min){
		return (min * 60 * 1000);
	}
}
