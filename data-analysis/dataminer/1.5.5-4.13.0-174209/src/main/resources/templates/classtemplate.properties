package=package org.gcube.dataanalysis.wps.statisticalmanager.synchserver.mappedclasses.#PACKAGE#;
import=import java.io.File;\nimport java.net.URL;\nimport org.n52.wps.algorithm.annotation.MethodOrder;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.LinkedHashMap;\nimport java.io.StringWriter;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.xmlbeans.XmlObject;\nimport org.gcube.dataanalysis.wps.statisticalmanager.synchserver.bindings.*;\nimport org.n52.wps.algorithm.annotation.*;\nimport org.n52.wps.io.data.*;\nimport org.n52.wps.io.data.binding.complex.*;\nimport org.n52.wps.io.data.binding.literal.*;\nimport org.n52.wps.server.*;import org.gcube.dataanalysis.wps.statisticalmanager.synchserver.mapping.AbstractEcologicalEngineMapper;import org.n52.wps.server.*;import org.gcube.dataanalysis.wps.statisticalmanager.synchserver.mappedclasses.*;
description=@Algorithm(statusSupported=true, title="#TITLE#", abstrakt="#ABSTRACT#", identifier="org.gcube.dataanalysis.wps.statisticalmanager.synchserver.mappedclasses.#PACKAGE#.#CLASSNAME#", version = "1.1.0")
class_definition=public class #CLASSNAME# extends AbstractEcologicalEngineMapper implements #INTERFACE#{
class_closure=@Execute	public void run() throws Exception {		super.run();	} }
stringInput=@MethodOrder(value=#ORDER_VALUE#)\n@LiteralDataInput(abstrakt="#ABSTRACT#", defaultValue="#DEFAULT#", title="#TITLE#", identifier = "#ID#", maxOccurs=1, minOccurs=1, binding = LiteralStringBinding.class) public void set#IDMETHOD#(String data) {inputs.put(\"#ID#\",data);}
enumeratedInput=@MethodOrder(value=#ORDER_VALUE#)\n@LiteralDataInput(abstrakt="#ABSTRACT#", allowedValues= {#ALLOWED#}, defaultValue="#DEFAULT#", title="#TITLE#", identifier = "#ID#", maxOccurs=1, minOccurs=1, binding = LiteralStringBinding.class) public void set#IDMETHOD#(String data) {inputs.put(\"#ID#\",data);}
doubleInput=@MethodOrder(value=#ORDER_VALUE#)\n@LiteralDataInput(abstrakt="#ABSTRACT#", defaultValue="#DEFAULT#", title="#TITLE#", identifier = "#ID#", maxOccurs=1, minOccurs=1, binding = LiteralDoubleBinding.class) public void set#IDMETHOD#(Double data) {inputs.put(\"#ID#\",""+data);}
integerInput=@MethodOrder(value=#ORDER_VALUE#)\n@LiteralDataInput(abstrakt="#ABSTRACT#", defaultValue="#DEFAULT#", title="#TITLE#", identifier = "#ID#", maxOccurs=1, minOccurs=1, binding = LiteralIntBinding.class) public void set#IDMETHOD#(Integer data) {inputs.put(\"#ID#\",""+data);}
booleanInput=@MethodOrder(value=#ORDER_VALUE#)\n@LiteralDataInput(abstrakt="#ABSTRACT#", defaultValue="#DEFAULT#", allowedValues= {"true","false"}, title="#TITLE#", identifier = "#ID#", maxOccurs=1, minOccurs=1,binding = LiteralBooleanBinding.class) public void set#IDMETHOD#(Boolean data) {inputs.put(\"#ID#\",""+data);}
csvFileInput=@MethodOrder(value=#ORDER_VALUE#)\n@ComplexDataInput(abstrakt="#ABSTRACT#", title="#TITLE#", maxOccurs=1, minOccurs=1, identifier = "#ID#", binding = GenericFileDataBinding.class)	public void set#IDMETHOD#(GenericFileData file) {inputs.put(\"#ID#\",file);}
gislinkInput=@MethodOrder(value=#ORDER_VALUE#)\n@ComplexDataInput(abstrakt="#ABSTRACT#", title="#TITLE#", maxOccurs=1, minOccurs=1, identifier = "#ID#", binding = GisLinkDataInputBinding.class)	public void set#IDMETHOD#(GenericFileData file) {inputs.put(\"#ID#\",file);}
d4scienceFileInput=@MethodOrder(value=#ORDER_VALUE#)\n@ComplexDataInput(abstrakt="#ABSTRACT#", title="#TITLE#", maxOccurs=1, minOccurs=1, identifier = "#ID#", binding = D4ScienceDataInputBinding.class)	public void set#IDMETHOD#(GenericFileData file) {inputs.put(\"#ID#\",file);}
d4scienceFileOutput=@MethodOrder(value=#ORDER_VALUE#)\n@ComplexDataOutput(abstrakt="#ABSTRACT#", title="#TITLE#", identifier = "#ID#", binding = D4ScienceFileDataBinding.class)	public GenericFileData get#IDMETHOD#() {URL url=null;try {url = new URL((String) outputs.get("#ID#")); return new GenericFileData(url.openStream(),"application/d4science");} catch (Exception e) {e.printStackTrace();return null;}}
pngFileOutput=@MethodOrder(value=#ORDER_VALUE#)\n@ComplexDataOutput(abstrakt="#ABSTRACT#", title="#TITLE#", identifier = "#ID#", binding = PngFileDataBinding.class)	public GenericFileData get#IDMETHOD#() {URL url=null;try {url = new URL((String) outputs.get("#ID#")); return new GenericFileData(url.openStream(),"image/png");} catch (Exception e) {e.printStackTrace();return null;}}
csvFileOutput=@MethodOrder(value=#ORDER_VALUE#)\n@ComplexDataOutput(abstrakt="#ABSTRACT#", title="#TITLE#", identifier = "#ID#", binding = CsvFileDataBinding.class)	public GenericFileData get#IDMETHOD#() {URL url=null;try {url = new URL((String) outputs.get("#ID#")); return new GenericFileData(url.openStream(),"text/csv");} catch (Exception e) {e.printStackTrace();return null;}}
gisLinkOutput=@MethodOrder(value=#ORDER_VALUE#)\n@ComplexDataOutput(abstrakt="#ABSTRACT#", title="#TITLE#", identifier = "#ID#", binding = GisLinkDataBinding.class)	public GenericFileData get#IDMETHOD#() {URL url=null;try {url = new URL((String) outputs.get("#ID#")); return new GenericFileData(url.openStream(),"application/geotiff");} catch (Exception e) {e.printStackTrace();return null;}}
stringOutput=@MethodOrder(value=#ORDER_VALUE#)\n@LiteralDataOutput(abstrakt="#ABSTRACT#", title="#TITLE#", identifier = "#ID#", binding = LiteralStringBinding.class)	public String get#IDMETHOD#() {return (String) outputs.get("#ID#");}
optionalOutput=@MethodOrder()\n@ComplexDataOutput(abstrakt="Output that is not predetermined", title="NonDeterministicOutput", identifier = "non_deterministic_output", binding = GenericXMLDataBinding.class)\n public XmlObject getNon_deterministic_output() {return (XmlObject) outputs.get("non_deterministic_output");}